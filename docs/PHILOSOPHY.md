# LACE Philosophy: Deterministic Governance for AI-Driven SDLCs

## 1. AI-Accelerated Entropy
Software teams increasingly pair-program with AI assistants. These systems draft glue code, port patterns between services, and propose refactors in seconds. The acceleration is valuable, yet it exposes an architectural gap: assistants do not remember the rules that keep a codebase stable. A model may suggest importing `src/data/internal` into a UI component, wiring an experimental feature into a critical path, or shelling out to an unsanctioned binary. The human reviewing the change absorbs the cost. Multiply this across hundreds of suggestions per week and entropy grows faster than code reviewers can counteract it. LACE exists because governance must run at the same speed as generation. Policies, decisions, and requirements must be encoded alongside code and enforced deterministically whenever a file is evaluated.

## 2. Why Linters and Static Analyzers Are Insufficient
Traditional linters target syntax and style. Even sophisticated static analyzers focus on dataflow, null safety, or security patterns. They rarely ship with built-in rules such as “UI modules may only import API clients” or “Drivers depend on interfaces, never concrete services.” Customizing them often requires repository-wide indexing, database-backed servers, and background daemons. LACE deliberately avoids this overhead. It inspects only the file a developer touches (or explicitly passes to the CLI), evaluates policies tied to that file’s path, and emits deterministic diagnostics plus a bounded context block. The goal is not exhaustive semantic analysis; it is predictable enforcement of the policies that teams already agree on.

## 3. Prompt Engineering Cannot Replace Governance
Developers frequently prepend prompts with reminders: “Do not call the database directly,” or “Only use safe commands in this script.” Prompt-based hints are fragile. They rely on human memory, compete with real code in the context window, and vanish as soon as the suggestion is accepted. They also do nothing once the code is in CI. LACE codifies those reminders as YAML policies and decisions. When the engineer runs the VSCode command, LACE injects a structured block describing the file’s invariants, applicable decisions, requirement references, and current violations. When CI runs `lace-cli evaluate`, it evaluates the same policies and decisions without needing a prompt. Prompt engineering remains useful for shaping AI responses, but governance becomes declarative and reproducible.

## 4. Determinism as a Design Constraint
Governance tooling either produces reproducible signals or becomes noise. LACE treats determinism as non-negotiable. Policies, decisions, and requirements are stored in `.lace/` and reviewed like code. The parser reads only the active file and uses anchored regex patterns to avoid backtracking surprises. The context compiler sorts invariants, decisions, requirements, and violations before rendering text and truncates deterministically. Entropy scores and ETI values are rounded to four decimals; differences below 0.0001 are collapsed to zero. CLI output is sorted and timestamp-free, enabling byte-identical JSON across repeated runs. Determinism is not just a quality attribute—it is what makes LACE suitable for CI gating, because the signal never fluctuates between runs.

## 5. Bounded Entropy and the ETI
The Scientific Entropy Model blends five normalized components: Violation Recurrence Score (VRS), Policy Drift Score (PDS), Decision Drift Score (DDS), Context Inflation Score (CIS), and Coupling Score (SCS). Each component is confined to `[0,1]` via simple formulas (e.g., `min(strictViolations/10, 1)` or `violatedPolicies/totalPolicies`). The weighted sum produces `E(f)` for the current file. LACE rounds `E(f)` to four decimals and stores it in `.lace/state.json` alongside violation counts. The Entropy Trend Index records `E_current - E_previous`, also rounded and tolerance-clamped. Because entropy is bounded and deterministic, CI thresholds (`maxEntropyScore`, `maxContextInflation`, `failOnDecisionDrift`) remain meaningful across repositories. There is no probabilistic scoring or statistical smoothing; entropy is an explicit summary of governance health per file.

## 6. File-Scoped Evaluation and the No-Indexing Rule
Indexing entire repositories demands background daemons, incremental rebuilds, and large caches. Those requirements make many organizations avoid architectural analysis entirely. LACE enforces the opposite rule: evaluate only the files the developer touches. Policies and decisions use glob-based scopes rather than cross-file AST references. The CLI accepts explicit file lists and does not scan beyond them. This constraint keeps runtime linear in file size, preserves privacy (no hidden file reads), and ensures the tool can run in minimal environments, including air-gapped CI runners. It also aligns with the deterministic philosophy: fewer moving parts means fewer nondeterministic failure modes.

## 7. Local-First, No Daemons, No LLMs
LACE runs as a VSCode command and a CLI. When the command finishes, the process exits; no agent stays resident. CLI evaluations parse YAML and files within the process lifetime only. There is no embedded LLM, no prompt generation, and no remote service dependency. Teams already have assistants (Copilot, Cursor, etc.). LACE focuses on the governance layer around them, ensuring the assistant receives a consistent context block and that CI enforces the same policies deterministically. Local-first execution also simplifies audits: everything the tool reads is under `.lace/` or the explicit file list, and there is no hidden telemetry.

## 8. YAML as the Governance Single Source of Truth
Policies, decisions, and requirements are explicit YAML documents. Each policy includes `id`, `description`, `language`, `scope` (glob + optional function regex), forbidden and required imports/calls, severity, and optional `origin` linking back to a decision. Decisions document rationale and affected modules. Requirements link high-level obligations to module globs and optional decision IDs. Because configuration lives next to code, policy updates go through the same review process as feature changes. When a diagnostic fires, the policy ID and decision ID appear so developers can trace the rationale. There are no hidden heuristics or runtime-learned rules; everything is declarative and diffable.

## 9. Context Injection as a Repeatable Artifact
When the developer requests context, LACE emits a block summarizing the language, file path, function scope, applicable invariants, decisions, requirement, and violations. The block is ≤400 tokens, sorted, truncation-aware, and either inserted into the file, placed at the top, copied to the clipboard, or skipped (smart skip) if no governance data applies. Because the content is deterministic, it doubles as documentation in code review and as a consistent prompt extension for AI assistants. It never includes secrets or uncontrolled context because it is derived entirely from the active file and declarative policies.

## 10. CLI Philosophy and Exit Codes
`lace-cli` brings the same deterministic governance to CI. `evaluate` loads policies, decisions, and requirements once per invocation, evaluates each file, outputs deterministic plain text or JSON, and exits with stable codes (0 success, 1 strict violations, 2 CI threshold failure). `validate-config` checks for duplicate IDs, invalid globs, and orphaned references, exiting with 0 or 3. `pr-summary` aggregates affected decisions, requirements, strict violations, and entropy deltas for changed files, again with sorted output. There are no new flags without a version bump, no hidden settings, and no side effects beyond writing `.lace/state.json` (which stores only bounded aggregates).

## 11. Regex and YAML Safety
Regex-based import detection can become a liability if patterns are greedy or backtracking-heavy. LACE audits its patterns carefully: C++ includes use `^#\s*include\s*[<"]([^>"]+)`, Python imports use `^from\s+([\w\.]+)`/`^import\s+([\w\.]+)`, shell `source` detection relies on anchored expressions, and function calls use `\b([A-Za-z_][A-Za-z0-9_]*)\s*\(` with ignore lists. Tests cover 10k-character single-line files to ensure evaluation remains fast. YAML parsing is now cached per CLI process so large policy sets are read once per command, keeping performance linear while preserving determinism.

## 12. State Management and Corruption Recovery
`.lace/state.json` stores only `violations`, `files`, and `entropy`. If the file is missing or corrupt, LACE logs a warning and resets the state. Entries are sanitized to prevent unbounded growth or unexpected keys. Entropy values are stored with four-decimal precision. There is no history array or timestamp log—state remains a compact summary suitable for version control or regeneration.

## 13. Long-Term Vision
The roadmap prioritizes stability milestones over feature additions. Phase 5B2 focuses on stress and scaling validation (50+ files, 100 policies, 30 decisions, 50 requirements) to prove linear performance. Phase 5C addresses final CI robustness and documentation before tagging 1.0.0. Post-1.0.0, the aim is to keep governance deterministic while allowing the community to extend policies and adapters. New features will continue to respect the guardrails: file-scoped evaluation, local-first execution, explicit configuration, bounded entropy, and reproducible outputs.

In essence, LACE treats governance as code. AI can suggest changes quickly, but only deterministic guardrails keep those suggestions aligned with the architecture. By staying file-scoped, local-first, and declarative, LACE offers a governance layer teams can trust in both IDEs and CI.
